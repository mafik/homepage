---
title_pl: Automat
title_en: Automat
desc_pl: Automat stawia sobie za cel możliwość sterowania grami komputerowymi. Jest to pierwszy krok na drodze do stworzenia bardziej egalitarnego środowiska cyfrowego.
desc_en: Automat's objective is to be able to semi-autonomously play a variety of games. It's the first step towards a more general environment for interacting with computers.
renderer: render_article
thumb: page.png
date: 2024-10-27
---

<h1>Automat</h1>

<p lang=pl>Pomimo, że komputery od początku rewolucji cyfrowej oferują bezprecedensowe możliwości automatyzacji, to możliwość kierowania nimi przypada dość elitarnej grupie wykwalifikowanych technicznie osób. Chodzi mi tu o grupę inżynierów, programistów, także samouków, którzy, w ramach różnych struktur społecznych, pośredniczą między potrzebami grupy nietechnicznych użytkowników, a światem cyfrowym. Przyjmujemy już niemal za pewnik, że aby korzystać z komputerów potrzebne są pewne <em>kompetencje cyfrowe</em>. Stanowią element programu nauczania na wszystkich etapach, a ich zwieńczeniem jest umiejętność <em>programowania</em>. Zdolność, której nabycie wymaga czasu i wysiłu porównywalnego z nauką nowego języka obcego.
<p lang=en>Although computers have offered unprecedented opportunities for automation since the dawn of the information age, the ability to direct them falss to a fairly elite group of technically skilled individuals. By this I mean a group of engineers, programmers, including self-taught professionals, who, within various social structures, mediate between the needs of non-technical users and the digital world. We almost take it for granted that using computers requires certain <em>computer literacy</em>. They are part of the curriculum at all stages, and their culmination is the ability to <em>program</em>. An ability that requires time and effort comparable to learning a new foreign language.

<p lang=pl>Nawet umiejętność programowania nie gwarantuje jednak, że komputer uda się nagiąć do woli programisty. Wiele współczesnych urządzeń projektowanych jest tak, aby jedynie ich producent miał dostęp do działającego na nim programu. Dostęp ograniczany jest za pomocą zabezpieczeń kryptograficznych, ograniczania dostępu do dokumentacji technicznej, czy też ukrywania interfejsów no różne sposoby.
<p lang=en>Even the ability to program, however, does not guarantee that a computer can be bent to the programmer's will. Many modern devices are designed so that only their manufacturer has access to the program running on it. Access is limited by cryptographic means, lack of technical documentation, or physically hiding interfaces from access by users.

<p lang=pl>Zjawisko, które leży mi na sercu nosi nazwę <strong>wykluczenia cyfrowego</strong>. Chciałbym jednak, spojrzeć na nie nieco szerzej oraz z nieco innej strony.
<p lang=en>The phenomenon that is on my mind is called <strong>digital divide</strong>. I would like, however, to look at it a bit more broadly and from a slightly different angle.

<h2 lang=pl>Izolacjonizm cyfrowy kontra siłowa interoperacyjność</h2>
<h2 lang=en>Izolacjonizm cyfrowy kontra siłowa interoperacyjność</h2>

<p lang=pl>Zwykle myślimy o wykluczeniu cyfrowym jako czymś co dotyka osoby bez umiejętności obsługi komputera - a więc osoby starsze, czy też takie, których praca i styl życia zwyczajnie nie stykają się z komputerami. Wydaje mi się jednak, że rozwój zamkinętych ekosystemów prowadzi do podobnego zjawiska także w świecie cyfrowych tubylców. Ekspert działający w obszarze systemów wbudowanych (miniaturowych komputerów sterujących np. pralkami czy ekspresami do kawy) będzie mieć problemy próbując uruchomić serwis internetowy czy też pisząc aplikację mobilną. Nawet pomiędzy różnymi platformami mobilnymi występują różnice tak duże, że wymagana jest specjalizacja. Mamy więc osobnych programistów aplikacji iOS oraz programistów aplikacji Android. Akceptujemy to jako fakt i oczywistość. Czy aby na pewno musi tak być? Program działający na urządzeniu wbudowanym działa, rzecz jasna, w zupełnie innym środowisku niż aplikacja mobilna, ale istnieje między nimi pewne podobieństwo - struktury danych, mechanizmy sterowania, a także organizacja kodu to pewne uniwersalia, które nie różnią się właściwie na żadnym komputerze (wykluczając pewne egzotyczne architektury). Czemu więc nie powstały wciąż narzędzia uniwersalne - do pracy na każdym komputerze? Do pewnego stopnia rozwiązania takie powstały - są nimi na przykład języki Java czy JavaScript. Same języki programowania nie wystarczą jednak do zburzenia ścian dzielących ekosystemy. Zwłaszcza, kiedy ekosystemy te "nie chcą" być ze próbują być ze sobą kompatybilne.
<p lang=en>We usually think of digital exclusion as something that affects people without computer skills - that is, the elderly, or those whose jobs and lifestyles simply don't come into contact with computers. However, it seems to me that the development of closed ecosystems is leading to a similar phenomenon in the world of digital natives as well. An expert working in the area of embedded systems (miniature computers that control washing machines or coffee makers, for example) will have problems trying to run a web service or write a mobile application. Even between different mobile platforms there are differences so great that specialization is required. So we have separate iOS app developers and Android app developers. We accept this as a fact and a matter of course. But surely it must be so? A program running on an embedded device runs, of course, in a completely different environment than a mobile application, but there is a certain similarity between them - data structures, control mechanisms, as well as code organization are certain universals that do not actually differ on any computer (excluding some exotic architectures). So why haven't universal tools still been created - to work on any computer? To some extent, such solutions have been created - they are, for example, Java or JavaScript languages. However, programming languages alone are not enough to tear down the walls that divide ecosystems. Especially when these ecosystems “don't want” to be compatible with each other.

<p lang=pl>Mogąć coś nazwać, łątwiej jest temu czemuś się przyjrzeć i to zrozumieć. Zjawisko to, z braku istniejącego określenia możemy nazwać <em>izolacjonizmem cyfrowym</em>. Polega on na tym, że ekosystem cyfrowy wykazuje brak zainteresowania zgodnością z innymi technologiami. Oczywiście zwykle jest to uzasadnione różnymi argumentami - technicznymi, filozoficznymi, ekonomicznymi... Podobnie jak izolacjonizm w świecie polityki, izolacjonizm cyfrowy może mieć różne podłoża. Łączy je jednak dążenie do odizolowania się od pozostałych ekosystemów.
<p lang=en>When you can name something, it is easier to look at it and understand it. For lack of an existing term, we can call this phenomenon <em>digital isolationism</em>. It consists in the fact that the digital ecosystem shows a lack of interest in compatibility with other technologies. Of course, this is usually justified by various arguments - technical, philosophical, economic... Like isolationism in the world of politics, digital isolationism can have various bases. However, they are united by the desire to isolate themselves from other ecosystems.

<p lang=pl>Izolacjonizm cyfrowy ma oczywiście bezpośrednie przełożenie na zjawisko wykluczenia cyfrowego. Bifurkacja technologii oznacza, że nabycie kompetencji cyfrowych wiąże się z kosztem proporcjonalnym do ich liczby. Na najbardziej podstawowym poziomie oznacza to, że obsługi każdego programu uczyć się trzeba osobno, ponieważ występują między nimi znaczące różnice. To samo tyczy się różnych platform, różnych języków programowania etc. Izolacjonizm cyfrowy to jedna z przyczyn dla których każdy problem informatyczny posiada dziesiątki różnych rozwiązań, z których każde wymaga od użytkownika czasochłonnej nauki.
<p lang=en>Digital isolationism obviously has a direct bearing on the phenomenon of digital exclusion. The bifurcation of technologies means that acquiring digital competencies comes at a cost proportional to their number. At the most basic level, this means that the operation of each program must be learned separately, since there are significant differences between them. The same goes for different platforms, different programming languages, etc. Digital isolationism is one of the reasons why every IT problem has dozens of different solutions, each of which requires time-consuming learning from the user.

<p lang=pl>Zaznaczę tu, że skojarzenia z mechanizmami wolnorynkowymi, gdzie różne technologie mogą współzawodniczyć między sobą są tu zupełnie nie trafione. Mechanizmy wolnorynkowe wymagają od konsumentów porównania wielu różnych narzędzi. Użytkownicy narzędzi cyfrowych, po nabyciu odpowiednich umiejętności tracą motywację do nauki nowego narzędzia. Nawet jeśli to nowe narzędzie rozwiązuje ten sam problem lepiej, to przez wydatek czasu potrzebny na jego naukę jest zwyczajnie nie opłacalne. W świecie cyfrowym działa także efekt kuli śnieżnej, który pomaga rozwiązaniom starszym i z większą bazą użytkowników.
<p lang=en>I will point out here that the association with free market mechanisms, where different technologies can compete with each other, is completely misplaced here. Free market mechanisms require consumers to compare many different tools. Users of digital tools, once skilled, lose motivation to learn a new tool. Even if the new tool solves the same problem better, by the expenditure of time needed to learn it, it is simply not worthwhile. There is also a snowball effect at work in the digital world, which helps solutions that are older and have a larger user base.

<p lang=pl>Inną kwestą jest to, że z punktu widzenia każdego ekosystemu, wprowadzanie własnych standardów postrzegane jest jako "standaryzacja", podczas gdy zupełnie zaniedbuje się zgodność z istniejącymi rozwiązaniami (interoperacyjność).
<p lang=en>Another issue is that from the point of view of any ecosystem, introducing its own standards is seen as “standardization,” while compatibility with existing solutions (interoperability) is completely neglected.

![https://xkcd.org/927/](standards.png)

<p lang=pl>Dopóki nie zburzymy ścian dzielących ekosystemy, hasła o budowaniu kompetencji cyfrowych oznaczać będą co najwyżej nabywanie kompetencji w danym ekosystemie, i wiązanie się z nim na trwałe. Potrzebujemy prawdziwie przenośnych narzędzi, takich które działają w każdych warunkach, na których możemy polegać, i których nauka nie oznaczać będzie trwałego związku z ich producentem.
<p lang=en>Until we break down the walls that divide ecosystems, slogans about building digital competence will at best mean acquiring competence in a given ecosystem, and tying ourselves to it permanently. We need truly portable tools, ones that work in all conditions, that we can rely on, and whose learning will not mean a permanent connection to their manufacturer.

<p lang=pl>Rozwiązanie, które proponuję nazywam <strong>siłową interoperacyjnością</strong> (ang. <em>adversarial interoperability</em>) i polega ono na tym, że nowy program, nazwijmy go sterownikiem, korzysta ze wszelkich dostępnych środków by zmusić oryginalne oprogramowanie do pracy zgodnej z pewnym ujednoliconym interfejsem. Środki wykorzystywane w tym celu mogą obejmować symulowanie zachowań użytkownika (myszki, klawiatury, etc.), manipulację pamięci programu, wirtualizację oraz wykorzystanie wewnętrznych interfejsów oryginalnego oprogramowania. W dużym uproszczeniu oznacza to, że zamiast korzystać z oryginalnego oprogramowania bezpośrednio, korzystamy ze sterownika, który steruje oryginalnym programem. Obecność sterownika powoduje, że wiele różnych narzędzi, które wcześniej były ze sobą niekompatybilne, stają się kompatybilne. Możliwe staje się przesyłanie między nimi danych i sygnałów. Wewnątrz sterownika zadania, które wymagały wcześniej od użytkownika kopiowania i wklejania danych pomiędzy programami, mogą być automatyzowane. Sterownik jest środowiskiem, które wymusza interoperacyjność na zewnętrznych systemach i dostarcza jednorodny interfejs - taki, który działa podobnie dla różnych sterowanych programów.
<p lang=en>The solution I propose is called <strong>adversarial interoperability</strong>, and it involves a new program, let's call it a driver, using whatever means possible to force the original software to work in accordance with some unified interface. The means used to achieve this may include simulating user behavior (mouse, keyboard, etc.), manipulating the program's memory, virtualization, and using the original software's internal interfaces. In simple terms, this means that instead of using the original software directly, we use a driver that controls the original program. The presence of the driver makes many different tools that were previously incompatible with each other compatible. It becomes possible to send data and signals between them. Within the driver, tasks that previously required the user to copy and paste data between programs can be automated. The driver is an environment that forces interoperability on external systems and provides a unified interface - one that works similarly for the different programs being controlled.

<p lang=pl>Siłowa interoperacyjność to kluczowy, ale nie jedyny krok, który jest moim zdaniem konieczny aby przeciwdziałać wykluczeniu cyfrowemu. Aby zrozumieć kolejny krok potrzebne nam będzie jednak nowe pojęcie - inwersja odpowiedzialności.
<p lang=en>Adversarial interoperability is a key step, but not the only one that I believe is necessary to counter digital exclusion. To understand the next step, however, we will need a new concept - accountability inversion.

<h2 lang=pl>Inwersja odpowiedzialności</h2>
<h2 lang=en>Inversion of responsibility</h2>

<p lang=pl>Współczesny system sprawiedliwości, za cel stawia sobie nie tylko karanie przestępców, ale także (a być może nawet przede wszystkim) ich resocjalizację. Oskarżeni stający przed sądami traktowani są nie jako obiektywni ludzie, podejmujący racjonalne decyzje, ale jako produkt środowiska, w którym przyszło im żyć. W spojrzeniu takim odpowiedzialność za przestępstwo może wcale nie leżeć w osobie oskarżonej, ale w ich środowisku. Nie trudno wyobrazić sobie chyba przestępstwa, które mogą wynikać z trudnej sytuacji życiowej, presji społecznej, czy też z patologicznego środowiska.
<p lang=en>The modern justice system, has as its goal not only the punishment of criminals, but also (and perhaps even primarily) their rehabilitation. Defendants standing before the courts are treated not as objective people, making rational decisions, but as a product of the environment in which they have come to live. In such a view, the responsibility for the crime may not lie at all in the person of the accused, but in their environment. It's probably not difficult to imagine crimes that may result from a difficult life situation, social pressure, or a pathological environment.

<p lang=pl>Z podobną perspektywą spotkałem się pracując nad cyberbezpieczeństwem w Google. W skali tej korporacji żaden z problemów nie da się rozwiązać manualnie gdyż ilość ruchu jest tam zwyczajnie przytłaczająca. Niemal każdą funkcję pełnią tam systemy informatyczne, zarządzane przez odpowiednie zespoły (dotyczy to także wszelkich systemów zarządzających bezpieczeństwem). Awaria dowolnego z tych systemów ma na tyle poważne konsekwencje (nie tylko dla Google, ale także dla wszystkich użytkowników korzystających z usług firmy), że wyznacza się dyżury nadzorujących ich pracę, a po awarii każdorazowo należy sporządzić dokument opisujący jej chronologię, wskazujący moment jej wykrycia oraz proces naprawy. Dokument taki nosi nazwę "postmortem" i jedną z najważniejszych zasad jego sporządzania jest nie wskazywanie winnego. Nazywa się to "blameless postmortem". Zamiast tego należy skupić się na mechanizmach które zawiodły oraz wskazać potenjalne rozwiązania, które zapobiegłyby podobnej awarii w przyszłości. Dzięki eliminacji winy można uzyskać bardziej obiektywne spojrzenie na problem. Żaden z pracowników mających informacje o awarii nie ma powodów by zatajać jakiekolwiek informacje - wręcz przeciwnie. Na przykład w hipotetycznej sytuacji, gdzie osoba odpowedzialna za system wyciszyła swój telefon, przez co nie usłyszała alarmu, winna nie jest osoba, która wyciszyła telefon, ale program sygnalizujący alarm - to on powinien przed wysłaniem alarmu wyłączyć wyciszenie telefonu. To właśnie osoby, które były najbliżej problemu, i które łatwo wskazać jako winnych, są w stanie zaproponować najlepsze rozwiązania na przyszłość.
<p lang=en>I encountered a similar perspective while working on cyber security at Google. On the scale of this corporation, none of the problems can be solved manually because the amount of traffic there is simply overwhelming. Almost every function there is performed by IT systems, managed by appropriate teams (this includes any security management systems). The failure of any of these systems has such serious consequences (not only for Google, but also for all users using the company's services) that on-call supervisors are appointed to oversee their work, and after each failure a document must be drawn up describing its chronology, indicating the moment it was detected and the process of repair. Such a document is called a “postmortem,” and one of the most important rules of drafting it is not to identify the guilty party. This is called a blameless postmortem. Instead, the focus should be on the mechanisms that failed and identify potential solutions that would prevent a similar failure in the future. By eliminating blame, you can get a more objective view of the problem. No employee with information about the failure has any reason to withhold any information - quite the contrary. For example, in a hypothetical situation where the person responsible for the system muted his or her phone, and as a result did not hear the alarm, the culprit is not the person who muted the phone, but the program signaling the alarm - it is the one who should have muted the phone before sending the alarm. It is the people who were closest to the problem, and who are easy to point to as the culprits, who are able to suggest the best solutions for the future.

<p lang=pl><em>Determinizm</em> mówi, że pojęcie winy czy odpowiedzialności nie ma, z punktu widzenia fizyki, sensu, ponieważ dany układ początkowy, jeśli jego stan jest dokładnie ustalony, zawsze doprowadzi do tego samego rezultatu. Z naszego punktu widzenia, odpowiedzialność jest jednak pojęciem przydatnym, ponieważ za jej pomocą możemy wskazać te elementy świata, na które mamy wpływ i które możemy zmienić by osiągnąć ustalony cel.
<p lang=en><em>Determinism</em> says that the concept of guilt or responsibility makes no sense, from the point of view of physics, because a given initial system, if its state is exactly fixed, will always lead to the same result. From our point of view, however, responsibility is a useful concept, because with it we can point out those elements of the world that we have influence over and can change to achieve a fixed goal.

<p lang=pl>Gdyby podobną inwersję odpowiedzialności zastosować do pojęcia <em>wykluczenia cyfrowego</em> to możemy dojść do ciekawych wniosków. Jeśli to nie wina osób nietechnicznych, że są nietechniczne, to jedynym podejrzanym pozostaje sama technologia. Zastanówmy się chwilę, które pojęcia ze świata informatyki są rzeczywiście uzasadnione i konieczne? Czy tak właściwie potrzebujemy języków programowania? Konsol i terminali do wydawania poleceń? Może istnieją lepsze sposoby prezentowania tego co dzieje się w pamięci komputera oraz kierowania jego działaniem? Być może zamiast zmuszać ludzi do myślenia w języku komputerów, to komputery mogłyby porozumiewać się bardziej ludzkim językiem?
<p lang=en>If a similar inversion of responsibility were to be applied to the concept of <em>digital exclusion</em> then we might come to some interesting conclusions. If it's not the non-technical people's fault for being non-technical, then the only suspect remains technology itself. Let's take a moment to consider which concepts from the world of computing are actually legitimate and necessary? Do we actually need programming languages? Consoles and terminals to issue commands? Perhaps there are better ways to present what is going on in the computer's memory and to direct its operation? Perhaps instead of forcing people to think in the language of computers, computers could communicate in a more human language?

<p lang=pl>Współczesne języki programowania mają za sobą historię sięgającą lat 60, a więc czasy komputerów, gdzie komunikacja odbywała się za pomocą kart perforowanych i drukarek, a nieco później monochromatycznego tekstu na niewielkich monitorach. Znaczna część pojęć i procesów z tamtego okresu wykorzystywana jest do dziś, pomimo że możliwości komputerów stale rosły. Dzisiejsze komputery, nawet te które nosimy w kieszeniach, mogą dynamicznie generować fotorealistyczną grafikę trójwymiarową, są w stanie reagować na dotyk, nagrywać i odtwarzać dźwięk, komunikować się bezprzewodowo, itd. Które z tych innowacji mogłyby pomóc w stworzeniu bardziej naturalnego środowiska do kierowania komputerami? Takiego, w którym "nabywanie kompetencji cyfrowych" nie jest konieczne, ponieważ cyfra wygląda i działa w nich niemal jak świat fizyczny?
<p lang=en>Modern programming languages have a history dating back to the 1960s, the days of computers, where communication was by punched cards and printers, and a little later monochrome text on small monitors. Much of the concepts and processes of that period are still used today, even though computer capabilities have steadily increased. Today's computers, even the ones we carry in our pockets, can dynamically generate photorealistic three-dimensional graphics, are able to respond to touch, record and play back sound, communicate wirelessly, and so on. Which of these innovations could help create a more natural environment for driving computers? One in which “acquiring digital competence” is not necessary, because digital looks and acts almost like the physical world in them?

<p lang=pl>Wcieleniem tej idei w życie jest <strong>skeumorfizm</strong>. Według skeumorfizmu interfejs użytkownika powinien swoim wyglądem i zachowaniem naśladować przedmioty codziennego użytku. Jest to motyw znany ze starszych wersji systemów Windows i MacOS, zwłaszcza w ich początkowych wersjach. Stąd wzięły się pojęcia kosza czy katalogów. Z biegiem czasu i rosnącym doświadczeniem użytkowników koncepcja ta została wyparta przez bardziej minimalistyczny interfejs oparty na piktogramach. Powód zmiany jest prosty - skeumorficznym formom towarzyszy infantylny wydźwięk, co kłóci się z profesjonalnym, skierowanym do ekspertów marketingiem.
<p lang=en>The embodiment of this idea is <strong>skeumorphism</strong>. According to skeumorphism, the user interface should mimic everyday objects in its appearance and behavior. This is a theme familiar from older versions of Windows and macOS, especially in their early versions. This is where the concepts of trash or directories came from. With the passage of time and growing user experience, this concept was supplanted by a more minimalist interface based on pictograms. The reason for the change is simple - skeumorphic forms are accompanied by infantile overtones, which is at odds with professional, expert-directed marketing.

<p lang=pl>Choć skeumorfizm popadł niemal w zapomnienie, wydaje mi się, że może być on kluczem do bardziej naturalnego interfejsu komputerowego. Świetnie rozumieją to twórcy gier komputerowych, którzy nie wsydzą się tekstur czy animacji. Wiele gier, tak właściwie stanowi obecnie furtkę dla młodych programistów - tytuły takie jak Roblox, Minecraft czy Factorio. Gry te pokazują, że można "programować" w inny sposób - bez języków czy kompilatorów. Bez całego bagażu, który ciągniemy aż od lat 60 ubiegłego wieku.
<p lang=en>Although skeumorphism has almost fallen into oblivion, it seems to me that it could be the key to a more natural computer interface. Greatly understood by computer game developers, who don't get sucked into textures or animation. Many games, in fact, are now providing a gateway for young programmers - titles such as Roblox, Minecraft and Factorio. These games show that you can “program” in a different way - without languages or compilers. Without all the baggage we've been hauling around since the 1960s.

<p lang=pl>Mógłbym dłużej wymieniać tu problemy i bolączki istniejących interfejsów komputerowych. Chociażby nastawienie na zysk, które to może być postrzegane jako źródło wielu niefortunnych decyzji i braku zaufania do producentów. Czy też rozrzutność zasobów komputera - pamięci i czasu procesora. Warto byłoby też wspomnieć o błędzie, jakim jest ignorowanie przez oprogramowanie nowych obszarów takich jak IoT czy VR... Ale robi się już dość późno i chciałbym przejść do rzeczy.
<p lang=en>I could go on for longer listing here the problems and ills of existing computer interfaces. For example, the profit orientation, which can be seen as the source of many unfortunate decisions and lack of trust in manufacturers. Or the wastefulness of computer resources - memory and processor time. It would also be worth mentioning the mistake of software ignoring new areas such as IoT and VR.... But it's getting pretty late and I'd like to get to the point.

<p lang=pl>Otóż pracuję nad nowym środowiskiem do pracy z komputerem. Nazywa się ono <em>Automat</em>.
<p lang=en>Well, I'm working on a new computer work environment. It's called <em>Automat</em>.

<h2>Automat</h2>

<p lang=pl>Automat stawia sobie za cel możliwość sterowania grami komputerowymi. Jest to pierwszy krok na drodze do stworzenia bardziej egalitarnego środowiska cyfrowego.
<p lang=en>Automat's objective is to be able to semi-autonomously play a variety of games. It's the first step towards a more general environment for interacting with computers.

<p lang=pl>Cel ten planuje osiągnąć poprzez <strong>siłową interoperacyjność</strong>, <strong>skeumorficzną wizualizację</strong> obiektów w pamięci komputera oraz <strong>niekomercyjny</strong> charakter projektu, w którym oprogramowanie udostępniane jest za darmo, wraz z kodem źródłowym. Projekt tworzony jest na fundamencie <strong>wydajnych</strong>, niskopoziomowych technologii i stara się być <strong>kompatybilny ze środowiskami przyszłości</strong> takimi jak VR czy IoT.
<p lang=en>This goal is planned to be achieved through <strong>forceful interoperability</strong>, <strong>skeumorphic visualization</strong> of objects in computer memory and the <strong>non-commercial</strong> nature of the project, in which the software is provided for free, along with the source code. The project is created on the foundation of <strong>efficient</strong>, low-level technologies and tries to be <strong>compatible with future environments</strong> such as VR or IoT.

<p lang=pl>Jest to projekt, nad którym pracuję od nieco ponad roku, choć może być postrzegany jako reinkarnacja <a href="/dessin/">innego projektu</a>, sprzed ponad 10 lat.
<p lang=en>This is a project I've been working on for a little over a year, although it can be seen as a reincarnation of <a href=“/dessin/”>another project</a>, from over 10 years ago.

<p lang=pl>Projekt, pomimo że wciąż daleki od ukończenia, niedawno osiągnął stan, w którym może wykonywać już pewne czynności, symulując działanie klawiatury i przycisków myszki. Dlatego chciałbym zaprosić chętnych do wypróbowania projektu na jego stronę - <a href="https://automat.org/">automat.org</a>, albo skrótem - na <a href="https://github.com/mafik/automat">GitHub-a</a>.
<p lang=en>The project, although still far from finished, has recently reached a state where it can perform some actions, simulating keyboard and mouse buttons. Therefore, I would like to invite those interested in trying the project to its website - <a href="https://automat.org/">automat.org</a>, or in short - on <a href="https://github.com/mafik/automat">GitHub-a</a>.

<p lang=pl>Natomiast tych co chcieliby porozmawiać, czy też połączyć siły, zapraszam na streamy, które nadaję na platformach <a href="https://youtube.com/@MarekRogalski/live">YouTube</a> oraz <a href="https://twitch.tv/maf_pl">Twitch</a> w poniedziałki, środy i piątki. Do zobaczenia!
<p lang=en>On the other hand, for those who would like to talk or join forces, I invite you to the streams I broadcast on <a href=“https://youtube.com/@MarekRogalski/live”>YouTube</a> and <a href=“https://twitch.tv/maf_pl”>Twitch</a> on Mondays, Wednesdays and Fridays. See you there!